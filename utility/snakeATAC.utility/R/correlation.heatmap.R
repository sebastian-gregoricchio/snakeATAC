#' @title correlation.heatmap
#'
#' @param correlation.matrix Path or data.frame of the correlation matrix generated by snakeATAC.
#' @param palette Vector of colors corresponding to the palette to use for the heatmap color scale. Default: \code{viridis::mako(100, direction = -1)}.
#' @param correlation.scale.limits Two-elements vector to indicate lower and higher limits, respectively, to apply to the correlation coefficient color scale. Default: \code{c(0,1)}.
#' @param dendrogram.position String indicating the position of the dendrogram. One among: "top", "bottom", "left", "right". Default: \code{"left"}.
#' @param dendrogram.color String indicating the color of the dendrogram lines. Default: \code{"black"}.
#' @param dendrogram.linewidth Numeric value indicating the line.width of the dendrogram. Default: \code{"black"}.
#' @param display.values Logical value indicating whether the correlation coefficient should be displayed for each cell. Default: \code{TRUE}.
#' @param values.color String indicating the color to use for the correlation coefficient labels. Default: \code{"white"}.
#' @param values.decimals Numeric value indicating the number of decimals at which round the correlation coefficient labels. Default: \code{2}.
#' @param values.font.size Numeric value indicating the font size of the correlation coefficient labels. Default: \code{2}.
#' @param values.transparency Numeric value between 0-1 indicating the transparency (alpha) of the correlation coefficient labels. Default: \code{1}, full color.
#' @param plot.title String indicating the main title of the plot. Default: \code{NULL}.
#' @param plot.subtitle String indicating the subtitle of the plot. Default: \code{NULL}.
#' @param clustering.method String indicating the clustering method to use. The value should be (an unambiguous abbreviation of) one among: 'ward.D', 'ward.D2', 'single', 'complete', 'average' (= UPGMA), 'mcquitty' (= WPGMA), 'median' (= WPGMC) or 'centroid' (= UPGMC).
#' @param excluded.samples String vector indicating the list of sample IDs to exclude from the plot. Default: \code{NULL}.
#' @param return.cluster.object Logical value indicating whether the clustering and distance object should be returned along with the plot. Default: \code{FALSE}, only the plot is returned.
#'
#' @return Either a ggplot object, or a list with ggplot object, distance and hclust objects
#'
#' @export correlation.heatmap



correlation.heatmap =
  function(correlation.matrix,
           palette = viridis::mako(100, direction = -1),
           correlation.scale.limits = c(0,1),
           exclude.diagonal = FALSE,
           dendrogram.position = "left",
           dendrogram.color = "black",
           dendrogram.linewidth = 0.5,
           display.values = TRUE,
           values.color = "white",
           values.decimals = 2,
           values.font.size = 2,
           values.transparency = 1,
           plot.title = NULL,
           plot.subtitle = NULL,
           clustering.method = "complete",
           excluded.samples = NULL,
           return.cluster.object = FALSE) {

    ## LIBRARIES
    require(ggplot2)
    require(dplyr)


    ## Check parameters
    if (!(tolower(dendrogram.position) %in% c("top", "bottom", "left", "right", "rigth"))) {
      return(warning("The 'dendrogram.position' must be a value among: 'top', 'bottom', 'left', 'right'."))
    } else if (tolower(dendrogram.position) == "rigth") {
      dendrogram.position = "right"
    }


    if (!(clustering.method %in% c("ward.D", "ward.D2", "single", "complete", "average", "mcquitty", "median", "centroid"))) {
      return(warning("The 'clustering.method' should be (an unambiguous abbreviation of) one of: 'ward.D', 'ward.D2', 'single', 'complete', 'average' (= UPGMA), 'mcquitty' (= WPGMA), 'median' (= WPGMC) or 'centroid' (= UPGMC)."))
    }



    ## Read correlation matrix
    if ("character" %in% class(correlation.matrix)) {
      corr_matrix = data.table::fread(correlation.matrix, data.table = F, check.names = F)
      colnames(corr_matrix) = gsub("'","",colnames(corr_matrix))
      rownames(corr_matrix) = gsub("'","",corr_matrix$V1)
      corr_matrix$V1 = gsub("'","",corr_matrix$V1)
    } else {
      corr_matrix = as.data.frame(corr_matrix)
      corr_matrix$V1 = rownames(corr_matrix)
    }


    ## Filter-out excluded samples (if required)
    if (!is.null(excluded.samples)) {
      if (FALSE %in% (excluded.samples %in% rownames(corr_matrix))) {
        message("Warning message:")
        message("At least one of the 'excluded samples' is not present in the ID list.\n")
        message(paste0("Missing 'excluded.samples': \n", paste0(excluded.samples[!(excluded.samples %in% rownames(corr_matrix))], collapse = ", "), ".\n"))
        message(paste0("IDs available: \n", paste0(sort(rownames(corr_matrix)), collapse = ", "), "."))
      }
      corr_matrix = corr_matrix[!(rownames(corr_matrix) %in% excluded.samples), !(colnames(corr_matrix) %in% excluded.samples)]
    }


    ## Define dendrogram
    distance = as.dist(1-dplyr::select(corr_matrix, -V1))
    corr_clust = hclust(d = distance, method = clustering.method)



    ## Reshape table
    matrix =
      reshape2::melt(data = corr_matrix,
                     value.name = "correlation",
                     id.vars = "V1") %>%
      dplyr::mutate(V1 = factor(V1, levels = rev(colnames(dplyr::select(corr_matrix, -V1))[corr_clust$order]))) %>%
      dplyr::mutate(variable = factor(variable, levels = rev(levels(V1))))

    if (exclude.diagonal == TRUE) {
      matrix = dplyr::filter(.data = matrix, V1 != variable)
    }


    ## Generate the basic plot
    corr_heatmap =
      ggplot(data = matrix,
             aes(x = V1,
                 y = variable,
                 fill = correlation)) +
      geom_tile() +
      xlab(NULL) +
      ylab(NULL) +
      scale_fill_gradientn(name = "Correlation\ncoefficient",
                           colours = palette,
                           limits = correlation.scale.limits,
                           na.value = palette[ncol(palette)]) +
      coord_fixed() +
      ggtitle(label = plot.title, subtitle = plot.subtitle) +
      theme(axis.text = element_text(color = "black"),
            axis.text.x = element_text(color = "black", angle = 90, hjust = 1, vjust = 0.5),
            panel.background = element_blank(),
            panel.grid = element_blank(),
            panel.border = element_rect(color = "black", linewidth = 1, fill = NA),
            aspect.ratio = 1,
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))


    if (tolower(dendrogram.position) %in% c("left", "right")) {
      corr_heatmap =
        corr_heatmap +
        scale_x_discrete(expand = c(0,0)) +
        ggh4x::scale_y_dendrogram(hclust = corr_clust,
                                  expand = c(0,0),
                                  position = tolower(dendrogram.position)) +
        theme(axis.ticks.y = element_line(color = dendrogram.color,
                                          linewidth = dendrogram.linewidth),
              axis.ticks.x = element_blank())
    } else {
      corr_heatmap =
        corr_heatmap +
        scale_y_discrete(expand = c(0,0)) +
        ggh4x::scale_x_dendrogram(hclust = corr_clust,
                                  expand = c(0,0),
                                  position = tolower(dendrogram.position)) +
        theme(axis.ticks.x = element_line(color = dendrogram.color,
                                          linewidth = dendrogram.linewidth),
              axis.ticks.y = element_blank())
    }


    ## Add values if required
    if (display.values == TRUE) {
      corr_heatmap =
        corr_heatmap +
        geom_text(aes(label = round(correlation, values.decimals)),
                  color = values.color,
                  size = values.font.size,
                  alpha = 1)
    }


    if (return.cluster.object == FALSE) {
      return(corr_heatmap)
    } else {
      # manually add attributes to cluster
      corr_clust$dist.method = "as.dist(1 - correlation.matrix)"
      corr_clust$call = paste0("hclust(d = as.dist(1 - correlation.matrix), method = ",clustering.method,")")
      return(list(heatmap = corr_heatmap,
                  distance = distance,
                  cluster = corr_clust))
    }
  }










